name: Preview Package Publishing

on:
  pull_request:
    branches: [feat/v3]
    types: [opened, synchronize, reopened]

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      packages-changed: ${{ steps.changes.outputs.packages }}
      other-files-changed: ${{ steps.changes.outputs.other }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            packages:
              - 'packages/**'
            other:
              - 'apps/**'
              - 'src/**'
              - 'docs/**'
              - 'components/**'
              - 'public/**'
              - '*.md'
              - '*.json'
              - '*.js'
              - '*.ts'
              - '*.tsx'
              - '*.css'
              - '*.scss'
              - '*.html'
              - '*.yml'
              - '*.yaml'
              - 'scripts/**'
              - 'templates/**'
              - '!packages/**'

  publish-preview:
    needs: check-changes
    if: needs.check-changes.outputs.packages-changed == 'true'
    runs-on: ubuntu-latest
    outputs:
      published: ${{ steps.publish.outputs.published }}
      version: ${{ steps.version.outputs.version }}
      packages: ${{ steps.publish.outputs.packages }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Generate preview version
        id: version
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          SHORT_SHA=$(git rev-parse --short HEAD)
          PREVIEW_VERSION="0.0.0-pr-${PR_NUMBER}-${SHORT_SHA}"
          echo "version=${PREVIEW_VERSION}" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è  Generated preview version: ${PREVIEW_VERSION}"

      - name: Update package versions
        run: |
          # Update only root-level package.json files in packages/ directory (not node_modules)
          for package_dir in packages/*/; do
            if [ ! -f "${package_dir}package.json" ]; then
              continue
            fi
            
            # Skip if it's a node_modules directory
            if [[ "$package_dir" == *"/node_modules/"* ]]; then
              continue
            fi
            
            package_file="${package_dir}package.json"
            
            # Create backup
            cp "$package_file" "$package_file.bak"
            
            # Update version using Node.js
            node -e "
              const fs = require('fs');
              const pkg = JSON.parse(fs.readFileSync('$package_file', 'utf8'));
              pkg.version = '${{ steps.version.outputs.version }}';
              fs.writeFileSync('$package_file', JSON.stringify(pkg, null, 2) + '\n');
            "
            
            echo "‚úÖ Updated version in $package_file to ${{ steps.version.outputs.version }}"
          done

      - name: Update internal package references
        run: |
          echo "üîÑ Updating internal package references to preview versions..."

          # Update all package.json files to reference the preview versions of internal packages
          for package_dir in packages/*/; do
            if [ ! -f "${package_dir}package.json" ]; then
              continue
            fi
            
            package_file="${package_dir}package.json"
            
            # Update dependencies that reference other packages in this monorepo
            node -e "
              const fs = require('fs');
              const path = require('path');
              const pkg = JSON.parse(fs.readFileSync('$package_file', 'utf8'));
              const previewVersion = '${{ steps.version.outputs.version }}';
              let changed = false;
              
              // Update dependencies
              ['dependencies', 'devDependencies', 'peerDependencies'].forEach(depType => {
                if (pkg[depType]) {
                  Object.keys(pkg[depType]).forEach(dep => {
                    // If this dependency starts with @gluestack-ui-nightly, update it to preview version
                    if (dep.startsWith('@gluestack-ui-nightly/')) {
                      console.log(\`Updating \${dep} from \${pkg[depType][dep]} to \${previewVersion} in \${depType}\`);
                      pkg[depType][dep] = previewVersion;
                      changed = true;
                    }
                  });
                }
              });
              
              if (changed) {
                fs.writeFileSync('$package_file', JSON.stringify(pkg, null, 2) + '\n');
                console.log('‚úÖ Updated dependencies in $package_file');
              } else {
                console.log('‚ÑπÔ∏è  No internal dependencies found in $package_file');
              }
            "
          done

      - name: Setup NPM authentication
        run: |
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > ~/.npmrc

      - name: Publish packages in correct order
        id: publish
        run: |
          # Create a temporary file to track published packages
          PUBLISHED_PACKAGES_FILE=$(mktemp)
          SUCCESS=false

          echo "üöÄ STARTING EXPLICIT PACKAGE PUBLISHING ORDER"
          echo "===================================================="

          # Function to publish a single package
          publish_package() {
            local package_dir="$1"
            local step_name="$2"
            
            echo ""
            echo "[$step_name] Attempting to publish: $package_dir"
            
            if [ ! -f "${package_dir}/package.json" ]; then
              echo "[$step_name] ‚ùå No package.json found in $package_dir"
              return 1
            fi
            
            # Get package info
            local PACKAGE_JSON=$(cat "${package_dir}/package.json")
            local PACKAGE_NAME=$(echo "$PACKAGE_JSON" | node -e "
              try {
                const pkg = JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8'));
                console.log(pkg.name || '');
              } catch(e) { console.log(''); }
            ")
            local IS_PRIVATE=$(echo "$PACKAGE_JSON" | node -e "
              try {
                const pkg = JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8'));
                console.log(pkg.private === true ? 'true' : 'false');
              } catch(e) { console.log('false'); }
            ")
            
            if [ -z "$PACKAGE_NAME" ]; then
              echo "[$step_name] ‚è≠Ô∏è  Skipping: No package name found"
              return 1
            fi
            
            if [ "$IS_PRIVATE" = "true" ]; then
              echo "[$step_name] ‚è≠Ô∏è  Skipping: Private package ($PACKAGE_NAME)"
              return 1
            fi
            
            echo "[$step_name] üì¶ Publishing: $PACKAGE_NAME"
            
            cd "$package_dir"
            
            # Clear npm cache to avoid workspace resolution issues
            echo "[$step_name] üóëÔ∏è  Clearing npm cache..."
            npm cache clean --force || echo "Cache clean failed, continuing..."
            
            # Remove existing node_modules and package-lock.json to ensure fresh install
            echo "[$step_name] üßπ Cleaning existing dependencies..."
            rm -rf node_modules package-lock.json yarn.lock || echo "Cleanup had issues, continuing..."
            
            # Install dependencies first to get latest preview packages
            echo "[$step_name] üì• Installing dependencies (fresh install)..."
            npm install --no-package-lock --registry https://registry.npmjs.org/ || echo "‚ö†Ô∏è  Install had issues, but continuing..."
            
            # Force install the specific preview version of utils if this is core package
            if [[ "$PACKAGE_NAME" == *"core"* ]]; then
              echo "[$step_name] üéØ Force installing preview utils package..."
              echo "[$step_name] üì¶ Attempting to install: @gluestack-ui-nightly/utils@${{ steps.version.outputs.version }}"
              
              # Capture npm install output for better error reporting
              if npm install @gluestack-ui-nightly/utils@${{ steps.version.outputs.version }} --no-save --registry https://registry.npmjs.org/ 2>&1; then
                echo "[$step_name] ‚úÖ Utils package installed successfully"
              else
                echo "[$step_name] ‚ö†Ô∏è  Utils install had issues, but continuing..."
                echo "[$step_name] üîç Checking if utils package is available on npm registry..."
                if npm view @gluestack-ui-nightly/utils@${{ steps.version.outputs.version }} version >/dev/null 2>&1; then
                  echo "[$step_name] ‚úÖ Utils package is available on npm registry"
                else
                  echo "[$step_name] ‚ùå Utils package NOT found on npm registry"
                  echo "[$step_name] üîç Available versions:"
                  npm view @gluestack-ui-nightly/utils versions --json 2>/dev/null || echo "[$step_name] Could not fetch available versions"
                fi
              fi
              
              # Verify utils package is available in node_modules
              if [ -d "node_modules/@gluestack-ui-nightly/utils" ]; then
                echo "[$step_name] ‚úÖ Utils package found in node_modules"
                UTILS_VERSION=$(node -e "try { console.log(require('./node_modules/@gluestack-ui-nightly/utils/package.json').version) } catch(e) { console.log('unknown') }")
                echo "[$step_name] üì¶ Installed utils version: $UTILS_VERSION"
                
                # Additional verification - check if package.json exists and is valid
                if [ -f "node_modules/@gluestack-ui-nightly/utils/package.json" ]; then
                  echo "[$step_name] ‚úÖ Utils package.json exists and is valid"
                else
                  echo "[$step_name] ‚ùå Utils package.json missing or invalid"
                fi
              else
                echo "[$step_name] ‚ùå Utils package NOT found in node_modules"
                echo "[$step_name] üîç Checking node_modules structure:"
                ls -la node_modules/@gluestack-ui-nightly/ 2>/dev/null || echo "[$step_name] No @gluestack-ui-nightly directory found"
              fi
            fi
            
            # Build the package
            if npm run --list 2>/dev/null | grep -q "\bbuild\b"; then
              echo "[$step_name] üî® Building $PACKAGE_NAME..."
              echo "[$step_name] üìã Available scripts:"
              npm run --list 2>/dev/null | grep -E "^(  [a-z]+|  [a-z]+:)" || echo "[$step_name] No scripts found"
              
              # Capture build output for better error reporting
              if npm run build 2>&1; then
                echo "[$step_name] ‚úÖ Build completed successfully for $PACKAGE_NAME"
              else
                echo "[$step_name] ‚ùå Build failed for $PACKAGE_NAME"
                echo "[$step_name] üîç Build error details:"
                echo "[$step_name] - Exit code: $?"
                echo "[$step_name] - Current directory: $(pwd)"
                echo "[$step_name] - Package.json exists: $([ -f "package.json" ] && echo "Yes" || echo "No")"
                echo "[$step_name] - Node modules exist: $([ -d "node_modules" ] && echo "Yes" || echo "No")"
                
                # Check for common build issues
                if [ ! -f "package.json" ]; then
                  echo "[$step_name] ‚ùå CRITICAL: package.json not found in $(pwd)"
                fi
                
                if [ ! -d "node_modules" ]; then
                  echo "[$step_name] ‚ùå CRITICAL: node_modules not found in $(pwd)"
                fi
                
                # Show package.json dependencies if available
                if [ -f "package.json" ]; then
                  echo "[$step_name] üìã Package dependencies:"
                  node -e "try { const pkg = JSON.parse(require('fs').readFileSync('package.json')); console.log('Dependencies:', Object.keys(pkg.dependencies || {}).length); console.log('DevDependencies:', Object.keys(pkg.devDependencies || {}).length); } catch(e) { console.log('Could not parse package.json'); }" 2>/dev/null || echo "[$step_name] Could not analyze package.json"
                fi
                
                cd - > /dev/null
                return 1
              fi
            else
              echo "[$step_name] ‚ÑπÔ∏è  No build script found for $PACKAGE_NAME, skipping build step"
            fi
            
            # Publish with preview tag
            echo "[$step_name] üöÄ Publishing to npm..."
            if npm publish --tag preview --access public; then
              echo "[$step_name] ‚úÖ SUCCESS: Published $PACKAGE_NAME@${{ steps.version.outputs.version }}"
              echo "$PACKAGE_NAME@${{ steps.version.outputs.version }}" >> "$PUBLISHED_PACKAGES_FILE"
              
              # Longer delay to ensure npm registry has the package
              echo "[$step_name] ‚è≥ Waiting 15 seconds for npm propagation..."
              sleep 15
              
              # Verify the package is available on npm registry
              echo "[$step_name] üîç Verifying package availability on npm..."
              for i in {1..6}; do
                if npm view "$PACKAGE_NAME@${{ steps.version.outputs.version }}" version >/dev/null 2>&1; then
                  echo "[$step_name] ‚úÖ Package confirmed available on npm registry"
                  break
                else
                  echo "[$step_name] ‚è≥ Package not yet available, waiting 10 more seconds... (attempt $i/6)"
                  sleep 10
                fi
              done
              
              cd - > /dev/null
              return 0
            else
              echo "[$step_name] ‚ùå FAILED to publish $PACKAGE_NAME"
              cd - > /dev/null
              return 1
            fi
          }

          # STEP 1: Publish utils package FIRST
          echo ""
          echo "üîß STEP 1: PUBLISHING UTILS PACKAGE"
          echo "===================================="
          UTILS_PUBLISHED=false

          # Try common utils directory names
          for utils_dir in "packages/gluestack-utils" "packages/utils" "packages/gluestack-ui-utils"; do
            if [ -d "$utils_dir" ]; then
              echo "Found utils directory: $utils_dir"
              if publish_package "$utils_dir" "UTILS"; then
                SUCCESS=true
                UTILS_PUBLISHED=true
                break
              fi
            fi
          done

          # If not found by directory, search by package name
          if [ "$UTILS_PUBLISHED" = false ]; then
            echo "Searching for utils package by name..."
            for dir in packages/*/; do
              if [ -f "${dir}package.json" ]; then
                pkg_name=$(node -e "try { console.log(JSON.parse(require('fs').readFileSync('${dir}package.json')).name || '') } catch(e) { console.log('') }")
                if [[ "$pkg_name" == *"@gluestack-ui-nightly/utils"* ]]; then
                  echo "Found utils package by name: $dir ‚Üí $pkg_name"
                  if publish_package "$dir" "UTILS"; then
                    SUCCESS=true
                    UTILS_PUBLISHED=true
                    break
                  fi
                fi
              fi
            done
          fi

          if [ "$UTILS_PUBLISHED" = false ]; then
            echo "‚ùå CRITICAL: Utils package not found or failed to publish!"
          fi

          # STEP 2: Publish core package SECOND  
          echo ""
          echo "üèóÔ∏è  STEP 2: PUBLISHING CORE PACKAGE"
          echo "==================================="
          CORE_PUBLISHED=false

          # Try common core directory names
          for core_dir in "packages/gluestack-core" "packages/core" "packages/gluestack-ui-core"; do
            if [ -d "$core_dir" ]; then
              echo "Found core directory: $core_dir"
              if publish_package "$core_dir" "CORE"; then
                SUCCESS=true
                CORE_PUBLISHED=true
                break
              fi
            fi
          done

          # If not found by directory, search by package name
          if [ "$CORE_PUBLISHED" = false ]; then
            echo "Searching for core package by name..."
            for dir in packages/*/; do
              if [ -f "${dir}package.json" ]; then
                pkg_name=$(node -e "try { console.log(JSON.parse(require('fs').readFileSync('${dir}package.json')).name || '') } catch(e) { console.log('') }")
                if [[ "$pkg_name" == *"@gluestack-ui-nightly/core"* ]]; then
                  echo "Found core package by name: $dir ‚Üí $pkg_name"
                  if publish_package "$dir" "CORE"; then
                    SUCCESS=true
                    CORE_PUBLISHED=true
                    break
                  fi
                fi
              fi
            done
          fi

          # STEP 3: Publish all other packages LAST
          echo ""
          echo "üì¶ STEP 3: PUBLISHING OTHER PACKAGES"
          echo "===================================="

          for dir in packages/*/; do
            if [ -f "${dir}package.json" ]; then
              pkg_name=$(node -e "try { console.log(JSON.parse(require('fs').readFileSync('${dir}package.json')).name || '') } catch(e) { console.log('') }")
              
              # Skip if it's utils or core (already published)
              if [[ "$pkg_name" == *"utils"* ]] || [[ "$pkg_name" == *"core"* ]]; then
                echo "‚è≠Ô∏è  Skipping already processed: $pkg_name"
                continue
              fi
              
              echo "Found other package: $dir ‚Üí $pkg_name"
              if publish_package "$dir" "OTHER"; then
                SUCCESS=true
              fi
            fi
          done

          echo ""
          echo "üìä PUBLISHING SUMMARY"
          echo "===================="
          echo "Utils published: $UTILS_PUBLISHED"
          echo "Core published: $CORE_PUBLISHED"

          if [ "$SUCCESS" = true ]; then
            # Read all published packages into a single variable
            PUBLISHED_PACKAGES=$(cat "$PUBLISHED_PACKAGES_FILE" | tr '\n' ' ' | sed 's/ $//')
            echo "published=true" >> $GITHUB_OUTPUT
            echo "packages=$PUBLISHED_PACKAGES" >> $GITHUB_OUTPUT
            echo "‚úÖ FINAL RESULT: SUCCESS"
            echo "üìã Published packages: $PUBLISHED_PACKAGES"
          else
            echo "published=false" >> $GITHUB_OUTPUT
            echo "‚ùå FINAL RESULT: FAILED - No packages were published successfully"
          fi

          # Cleanup
          rm -f "$PUBLISHED_PACKAGES_FILE"

      - name: Restore package.json files
        if: always()
        run: |
          # Restore original package.json files
          for package_dir in packages/*/; do
            if [ ! -f "${package_dir}package.json.bak" ]; then
              continue
            fi
            
            backup_file="${package_dir}package.json.bak"
            original_file="${package_dir}package.json"
            
            mv "$backup_file" "$original_file"
            echo "‚úÖ Restored $original_file"
          done

      - name: Comment on PR
        if: steps.publish.outputs.published == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const packages = `${{ steps.publish.outputs.packages }}`.trim();

            if (!packages) {
              console.log('No packages published, skipping comment');
              return;
            }

            const comment = `## üöÄ Preview packages published!

            **Version:** \`${{ steps.version.outputs.version }}\`

            **Published packages:**
            ${packages.split(' ').map(pkg => `- \`${pkg}\``).join('\n')}

            > üí° These are preview packages for testing only.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  trigger-vercel-preview-with-packages:
    needs: [check-changes, publish-preview]
    if: needs.check-changes.outputs.packages-changed == 'true' && needs.publish-preview.outputs.published == 'true'
    runs-on: ubuntu-latest
    outputs:
      deployed_projects: ${{ steps.deploy.outputs.deployed_projects }}
      deployment_urls: ${{ steps.deploy.outputs.deployment_urls }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Debug outputs
        run: |
          echo "üîç Debugging job outputs:"
          echo "Published: ${{ needs.publish-preview.outputs.published }}"
          echo "Version: ${{ needs.publish-preview.outputs.version }}"
          echo "Packages: ${{ needs.publish-preview.outputs.packages }}"
          echo "Packages changed: ${{ needs.check-changes.outputs.packages-changed }}"
          echo "Other files changed: ${{ needs.check-changes.outputs.other-files-changed }}"

      - name: Generate version for deployment
        id: version
        run: |
          # Use the published package version
          PACKAGE_VERSION="${{ needs.publish-preview.outputs.version }}"
          echo "üì¶ Using published package version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT

      - name: Discover and prepare preview packages
        id: prepare-packages
        run: |
          PREVIEW_VERSION="${{ needs.publish-preview.outputs.version }}"
          PUBLISHED_PACKAGES="${{ needs.publish-preview.outputs.packages }}"

          echo "üîç Discovering preview packages..."
          echo "üì¶ Preview version: $PREVIEW_VERSION"
          echo "üìã Published packages: $PUBLISHED_PACKAGES"

          # Parse published packages and extract package names
          PACKAGE_NAMES=""
          if [ -n "$PUBLISHED_PACKAGES" ]; then
            echo "$PUBLISHED_PACKAGES" | tr ' ' '\n' | while read -r pkg_with_version; do
              if [ -n "$pkg_with_version" ]; then
                # Extract package name (everything before @version)
                pkg_name=$(echo "$pkg_with_version" | sed 's/@[^@]*$//')
                if [ -n "$pkg_name" ]; then
                  echo "üì¶ Found package: $pkg_name"
                  echo "$pkg_name" >> /tmp/package_names.txt
                fi
              fi
            done
          fi

          # Read package names from temp file
          if [ -f /tmp/package_names.txt ]; then
            PACKAGE_NAMES=$(cat /tmp/package_names.txt | tr '\n' ' ' | sed 's/ $//')
            echo "üìã Package names: $PACKAGE_NAMES"
          fi

          # Save to GitHub outputs
          echo "package_names=$PACKAGE_NAMES" >> $GITHUB_OUTPUT

          # Cleanup
          rm -f /tmp/package_names.txt

      - name: Trigger Vercel Preview Deployments
        id: deploy
        run: |
          # Parse project IDs from secrets
          PROJECT_IDS='${{ secrets.VERCEL_PROJECT_IDS }}'
          DEPLOYED_PROJECTS=""
          DEPLOYMENT_URLS=""
          PACKAGE_VERSION="${{ steps.version.outputs.version }}"
          PACKAGE_NAMES="${{ steps.prepare-packages.outputs.package_names }}"

          echo "üì¶ Using version: $PACKAGE_VERSION"
          echo "üìã Package names: $PACKAGE_NAMES"

          if [ -z "$PACKAGE_VERSION" ]; then
            echo "‚ùå Version is empty, cannot proceed with deployment"
            exit 1
          fi

          # Use standard build command since packages are already specified in package.json
          BUILD_COMMAND="npm run build:preview"

          echo "üî® Build command: $BUILD_COMMAND"

          # Use process substitution to avoid subshell issues
          while IFS=':' read -r PROJECT_NAME PROJECT_ID; do
            echo "üöÄ Deploying $PROJECT_NAME (ID: $PROJECT_ID)..."
            
            # Create deployment using Vercel API with standard build command
            RESPONSE=$(curl -s -X POST "https://api.vercel.com/v13/deployments" \
              -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "{
                \"name\": \"$PROJECT_NAME\",
                \"project\": \"$PROJECT_ID\",
                \"gitSource\": {
                  \"type\": \"github\",
                  \"ref\": \"${{ github.head_ref }}\",
                  \"sha\": \"${{ github.sha }}\",
                  \"repoId\": ${{ github.event.repository.id }}
                },
                \"buildCommand\": \"$BUILD_COMMAND\",
                \"env\": {
                  \"PREVIEW_PACKAGES_VERSION\": \"$PACKAGE_VERSION\"
                },
                \"meta\": {
                  \"githubCommitSha\": \"${{ github.sha }}\",
                  \"githubCommitAuthorName\": \"${{ github.actor }}\",
                  \"githubCommitMessage\": \"${{ github.event.pull_request.title }}\",
                  \"githubPR\": \"${{ github.event.pull_request.number }}\",
                  \"triggeredBy\": \"github-actions\",
                  \"packageVersion\": \"$PACKAGE_VERSION\",
                  \"previewPackages\": \"$PACKAGE_NAMES\"
                }
              }")
            
            # Extract deployment URL and ID
            DEPLOYMENT_URL=$(echo "$RESPONSE" | jq -r '.url // empty')
            DEPLOYMENT_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
            ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message // empty')
            
            if [ -n "$DEPLOYMENT_URL" ] && [ -n "$DEPLOYMENT_ID" ]; then
              echo "‚úÖ Successfully triggered deployment for $PROJECT_NAME"
              echo "üìç Preview URL: https://$DEPLOYMENT_URL"
              DEPLOYED_PROJECTS="$DEPLOYED_PROJECTS $PROJECT_NAME"
              DEPLOYMENT_URLS="$DEPLOYMENT_URLS\\n- **$PROJECT_NAME**: https://$DEPLOYMENT_URL"
            else
              echo "‚ùå Failed to deploy $PROJECT_NAME"
              if [ -n "$ERROR_MESSAGE" ]; then
                echo "Error: $ERROR_MESSAGE"
              fi
              echo "Response: $RESPONSE"
            fi
          done < <(echo "$PROJECT_IDS" | jq -r 'to_entries[] | "\(.key):\(.value)"')

          # Save results for next step
          echo "deployed_projects=$DEPLOYED_PROJECTS" >> $GITHUB_OUTPUT
          echo "deployment_urls<<EOF" >> $GITHUB_OUTPUT
          echo "$DEPLOYMENT_URLS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update PR with Vercel deployment info
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentUrls = `${{ steps.deploy.outputs.deployment_urls }}`.trim();
            const deployedProjects = `${{ steps.deploy.outputs.deployed_projects }}`.trim();
            const packageVersion = `${{ steps.version.outputs.version }}`;
            const publishedPackages = `${{ needs.publish-preview.outputs.packages }}`.trim();

            if (!deployedProjects) {
              const errorComment = `## ‚ö†Ô∏è Vercel deployment failed
              
              No projects were deployed successfully. Please check the [workflow logs](${context.payload.repository.html_url}/actions/runs/${context.runId}) for details.
              `;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: errorComment
              });
              return;
            }

            const successComment = `## üöÄ Vercel preview deployments triggered successfully!

            **Version:** \`${packageVersion}\`
            **Triggered by:** Package changes and publishing

            **Preview packages published:**
            ${publishedPackages.split(' ').map(pkg => `- \`${pkg}\``).join('\n')}

            **Projects deployed:**${deploymentUrls}

            ‚è±Ô∏è Deployments are building. Check your [Vercel dashboard](https://vercel.com/dashboard) for detailed status.

            > üí° These deployments will use the preview packages specified in your project's package.json files.
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: successComment
            });

  trigger-vercel-preview-other-files:
    needs: check-changes
    if: needs.check-changes.outputs.other-files-changed == 'true' && needs.check-changes.outputs.packages-changed == 'false'
    runs-on: ubuntu-latest
    outputs:
      deployed_projects: ${{ steps.deploy.outputs.deployed_projects }}
      deployment_urls: ${{ steps.deploy.outputs.deployment_urls }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Debug outputs
        run: |
          echo "üîç Debugging job outputs:"
          echo "Packages changed: ${{ needs.check-changes.outputs.packages-changed }}"
          echo "Other files changed: ${{ needs.check-changes.outputs.other-files-changed }}"

      - name: Generate version for deployment
        id: version
        run: |
          # Generate a version for deployment tracking when no packages were published
          PR_NUMBER=${{ github.event.pull_request.number }}
          SHORT_SHA=$(git rev-parse --short HEAD)
          PACKAGE_VERSION="deploy-${PR_NUMBER}-${SHORT_SHA}"
          echo "üöÄ Generated deployment version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT

      - name: Check for existing preview packages
        id: check-packages
        run: |
          echo "üîç Checking for existing preview packages that might be relevant..."

          # Look for any @gluestack-ui-nightly packages in package.json files
          FOUND_PACKAGES=""

          # Search in common locations for package.json files
          for search_dir in "." "apps" "examples" "demos"; do
            if [ -d "$search_dir" ]; then
              find "$search_dir" -name "package.json" -not -path "*/node_modules/*" 2>/dev/null | while read -r pkg_file; do
                if [ -f "$pkg_file" ]; then
                  # Extract @gluestack-ui-nightly dependencies
                  deps=$(node -e "
                    try {
                      const pkg = JSON.parse(require('fs').readFileSync('$pkg_file', 'utf8'));
                      const allDeps = {...(pkg.dependencies || {}), ...(pkg.devDependencies || {}), ...(pkg.peerDependencies || {})};
                      const gluestackDeps = Object.keys(allDeps).filter(dep => dep.startsWith('@gluestack-ui-nightly/'));
                      console.log(gluestackDeps.join(' '));
                    } catch(e) { console.log(''); }
                  " 2>/dev/null)
                  
                  if [ -n "$deps" ]; then
                    echo "üì¶ Found @gluestack-ui-nightly packages in $pkg_file: $deps"
                    echo "$deps" >> /tmp/all_packages.txt
                  fi
                fi
              done
            fi
          done

          # Get unique package names
          if [ -f /tmp/all_packages.txt ]; then
            UNIQUE_PACKAGES=$(cat /tmp/all_packages.txt | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/ $//')
            echo "üìã Unique packages found: $UNIQUE_PACKAGES"
            echo "packages=$UNIQUE_PACKAGES" >> $GITHUB_OUTPUT
            rm -f /tmp/all_packages.txt
          else
            echo "‚ÑπÔ∏è  No @gluestack-ui-nightly packages found in project"
            echo "packages=" >> $GITHUB_OUTPUT
          fi

      - name: Trigger Vercel Preview Deployments
        id: deploy
        run: |
          # Parse project IDs from secrets
          PROJECT_IDS='${{ secrets.VERCEL_PROJECT_IDS }}'
          DEPLOYED_PROJECTS=""
          DEPLOYMENT_URLS=""
          PACKAGE_VERSION="${{ steps.version.outputs.version }}"
          EXISTING_PACKAGES="${{ steps.check-packages.outputs.packages }}"

          echo "üì¶ Using version: $PACKAGE_VERSION"
          echo "üìã Existing packages: $EXISTING_PACKAGES"

          if [ -z "$PACKAGE_VERSION" ]; then
            echo "‚ùå Version is empty, cannot proceed with deployment"
            exit 1
          fi

          # Create build command - use standard build since no new packages were published
          BUILD_COMMAND="npm run build"

          # If we found existing packages, we could optionally try to update them to latest
          if [ -n "$EXISTING_PACKAGES" ]; then
            echo "‚ÑπÔ∏è  Found existing @gluestack-ui-nightly packages, using standard build"
            echo "üìã Existing packages will use their current versions"
          fi

          echo "üî® Build command: $BUILD_COMMAND"

          # Use process substitution to avoid subshell issues
          while IFS=':' read -r PROJECT_NAME PROJECT_ID; do
            echo "üöÄ Deploying $PROJECT_NAME (ID: $PROJECT_ID)..."
            
            # Create deployment using Vercel API with Git source for code changes
            RESPONSE=$(curl -s -X POST "https://api.vercel.com/v13/deployments" \
              -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "{
                \"name\": \"$PROJECT_NAME\",
                \"project\": \"$PROJECT_ID\",
                \"gitSource\": {
                  \"type\": \"github\",
                  \"ref\": \"${{ github.head_ref }}\",
                  \"sha\": \"${{ github.sha }}\",
                  \"repoId\": ${{ github.event.repository.id }}
                },
                \"buildCommand\": \"$BUILD_COMMAND\",
                \"env\": {
                  \"DEPLOYMENT_TYPE\": \"other-files-only\"
                },
                \"meta\": {
                  \"githubCommitSha\": \"${{ github.sha }}\",
                  \"githubCommitAuthorName\": \"${{ github.actor }}\",
                  \"githubCommitMessage\": \"${{ github.event.pull_request.title }}\",
                  \"githubPR\": \"${{ github.event.pull_request.number }}\",
                  \"triggeredBy\": \"github-actions\",
                  \"packageVersion\": \"$PACKAGE_VERSION\",
                  \"deploymentType\": \"other-files-only\"
                }
              }")
            
            # Extract deployment URL and ID
            DEPLOYMENT_URL=$(echo "$RESPONSE" | jq -r '.url // empty')
            DEPLOYMENT_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
            ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message // empty')
            
            if [ -n "$DEPLOYMENT_URL" ] && [ -n "$DEPLOYMENT_ID" ]; then
              echo "‚úÖ Successfully triggered deployment for $PROJECT_NAME"
              echo "üìç Preview URL: https://$DEPLOYMENT_URL"
              DEPLOYED_PROJECTS="$DEPLOYED_PROJECTS $PROJECT_NAME"
              DEPLOYMENT_URLS="$DEPLOYMENT_URLS\\n- **$PROJECT_NAME**: https://$DEPLOYMENT_URL"
            else
              echo "‚ùå Failed to deploy $PROJECT_NAME"
              if [ -n "$ERROR_MESSAGE" ]; then
                echo "Error: $ERROR_MESSAGE"
              fi
              echo "Response: $RESPONSE"
            fi
          done < <(echo "$PROJECT_IDS" | jq -r 'to_entries[] | "\(.key):\(.value)"')

          # Save results for next step
          echo "deployed_projects=$DEPLOYED_PROJECTS" >> $GITHUB_OUTPUT
          echo "deployment_urls<<EOF" >> $GITHUB_OUTPUT
          echo "$DEPLOYMENT_URLS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update PR with Vercel deployment info
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentUrls = `${{ steps.deploy.outputs.deployment_urls }}`.trim();
            const deployedProjects = `${{ steps.deploy.outputs.deployed_projects }}`.trim();
            const packageVersion = `${{ steps.version.outputs.version }}`;
            const existingPackages = `${{ steps.check-packages.outputs.packages }}`.trim();

            if (!deployedProjects) {
              const errorComment = `## ‚ö†Ô∏è Vercel deployment failed
              
              No projects were deployed successfully. Please check the [workflow logs](${context.payload.repository.html_url}/actions/runs/${context.runId}) for details.
              `;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: errorComment
              });
              return;
            }

            let packageInfo = '';
            if (existingPackages) {
              packageInfo = `\n**Existing packages detected:**\n${existingPackages.split(' ').map(pkg => `- \`${pkg}\` (using current version)`).join('\n')}\n`;
            }

            const successComment = `## üöÄ Vercel preview deployments triggered successfully!

            **Version:** \`${packageVersion}\`
            **Triggered by:** Other file changes (no packages published)${packageInfo}

            **Projects triggered for preview:**${deploymentUrls}

            ‚è±Ô∏è Deployments are building. Check your [Vercel dashboard](https://vercel.com/dashboard) for detailed status.

            > üí° These are preview deployments for testing code changes only.
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: successComment
            });
