name: Production Package Publishing

on:
  push:
    branches: [feat/v3]
    paths:
      - 'packages/**'

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      packages-changed: ${{ steps.changes.outputs.packages }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            packages:
              - 'packages/**'

  publish-production:
    needs: check-changes
    if: needs.check-changes.outputs.packages-changed == 'true'
    runs-on: ubuntu-latest
    outputs:
      published: ${{ steps.publish.outputs.published }}
      version: ${{ steps.publish.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Setup NPM authentication
        run: |
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > ~/.npmrc

      - name: Version packages with changesets
        id: version
        run: |
          # Check if there are changesets to consume
          if [ -d ".changeset" ] && [ "$(ls -A .changeset/*.md 2>/dev/null | wc -l)" -gt 0 ]; then
            echo "ðŸ“ Consuming changesets..."
            yarn changeset:version
            
            # Check if any package.json was modified
            if git diff --quiet; then
              echo "No version changes needed"
              echo "version_changed=false" >> $GITHUB_OUTPUT
            else
              echo "Version changes detected"
              echo "version_changed=true" >> $GITHUB_OUTPUT
              
              # Get the new version from the first package (assuming monorepo versioning)
              NEW_VERSION=$(node -e "
                const fs = require('fs');
                const packages = fs.readdirSync('packages');
                for (const pkg of packages) {
                  try {
                    const pkgJson = JSON.parse(fs.readFileSync(\`packages/\${pkg}/package.json\`, 'utf8'));
                    if (!pkgJson.private) {
                      console.log(pkgJson.version);
                      break;
                    }
                  } catch (e) {}
                }
              ")
              echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
              
              # Commit version changes
              git config --local user.email "action@github.com"
              git config --local user.name "GitHub Action"
              git add .
              git commit -m "Version packages [skip ci]"
              git push
            fi
          else
            echo "No changesets found, skipping versioning"
            echo "version_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Publish packages
        id: publish
        if: steps.version.outputs.version_changed == 'true'
        run: |
          echo "ðŸš€ Publishing packages..."
          PUBLISHED_PACKAGES=""

          # Function to check if version exists on npm
          check_npm_version() {
            local package_name=$1
            local version=$2
            
            # Check if version exists on npm
            if npm view "$package_name@$version" version >/dev/null 2>&1; then
              echo "true"
            else
              echo "false"
            fi
          }

          # Function to get latest version from npm
          get_npm_latest_version() {
            local package_name=$1
            
            # Get latest version from npm
            local latest_version=$(npm view "$package_name" version 2>/dev/null || echo "0.0.0")
            echo "$latest_version"
          }

          # Function to increment version
          increment_version() {
            local version=$1
            local increment_type=${2:-patch} # patch, minor, major
            
            node -e "
              const semver = require('semver');
              const version = '$version';
              const incrementType = '$increment_type';
              console.log(semver.inc(version, incrementType));
            " 2>/dev/null || node -e "
              const version = '$version';
              const parts = version.split('.');
              parts[2] = (parseInt(parts[2]) + 1).toString();
              console.log(parts.join('.'));
            "
          }

          find packages -maxdepth 2 -name "package.json" -not -path "*/node_modules/*" -type f | while read file; do
            PACKAGE_DIR=$(dirname "$file")
            PACKAGE_JSON=$(cat "$file")
            PACKAGE_NAME=$(echo "$PACKAGE_JSON" | node -e "console.log(JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).name)")
            IS_PRIVATE=$(echo "$PACKAGE_JSON" | node -e "console.log(JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).private || false)")
            
            if [ "$IS_PRIVATE" = "true" ]; then
              echo "â­ï¸  Skipping private package: $PACKAGE_NAME"
              continue
            fi
            
            echo "ðŸ“¦ Processing $PACKAGE_NAME from $PACKAGE_DIR..."
            
            cd "$PACKAGE_DIR"
            
            # Get current package version
            CURRENT_VERSION=$(node -e "console.log(JSON.parse(require('fs').readFileSync('package.json', 'utf8')).version)")
            echo "ðŸ“‹ Current version: $CURRENT_VERSION"
            
            # Check if version already exists on npm
            VERSION_EXISTS=$(check_npm_version "$PACKAGE_NAME" "$CURRENT_VERSION")
            
            if [ "$VERSION_EXISTS" = "true" ]; then
              echo "âš ï¸  Version $CURRENT_VERSION already exists on npm for $PACKAGE_NAME"
              echo "ðŸ”„ Checking latest version on npm..."
              
              # Get latest version from npm
              NPM_LATEST=$(get_npm_latest_version "$PACKAGE_NAME")
              echo "ðŸ“¦ Latest version on npm: $NPM_LATEST"
              
              # Compare versions and update if needed
              if [ "$CURRENT_VERSION" = "$NPM_LATEST" ]; then
                echo "ðŸ“ˆ Incrementing patch version..."
                # Increment patch version
                NEW_VERSION=$(increment_version "$CURRENT_VERSION" "patch")
              else
                echo "ðŸ“ˆ Using next version after npm latest..."
                # Use next version after npm latest
                NEW_VERSION=$(increment_version "$NPM_LATEST" "patch")
              fi
              
              echo "ðŸ”„ Updating package version to $NEW_VERSION..."
              
              # Update package.json version
              node -e "
                const fs = require('fs');
                const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                pkg.version = '$NEW_VERSION';
                fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
              "
              
              # Update the version variable
              CURRENT_VERSION=$NEW_VERSION
              echo "âœ… Updated to version: $CURRENT_VERSION"
            fi
            
            # Build if build script exists
            if yarn run --list 2>/dev/null | grep -q "build"; then
              echo "ðŸ”¨ Building $PACKAGE_NAME..."
              yarn build
            fi
            
            # Publish to latest tag
            echo "ðŸš€ Publishing $PACKAGE_NAME@$CURRENT_VERSION..."
            
            # Try to publish with better error handling
            if npm publish --access public; then
              echo "âœ… Successfully published $PACKAGE_NAME@$CURRENT_VERSION"
              PUBLISHED_PACKAGES="$PUBLISHED_PACKAGES $PACKAGE_NAME@$CURRENT_VERSION"
            else
              PUBLISH_ERROR=$?
              echo "âŒ Failed to publish $PACKAGE_NAME@$CURRENT_VERSION (exit code: $PUBLISH_ERROR)"
              
              # Check if it's a version conflict error
              if [ $PUBLISH_ERROR -eq 1 ]; then
                echo "ðŸ”„ This might be a version conflict. Checking npm registry..."
                NPM_LATEST=$(get_npm_latest_version "$PACKAGE_NAME")
                echo "ðŸ“¦ Latest version on npm: $NPM_LATEST"
                
                if [ "$CURRENT_VERSION" = "$NPM_LATEST" ]; then
                  echo "ðŸ”„ Version conflict detected. Incrementing version and retrying..."
                  NEW_VERSION=$(increment_version "$CURRENT_VERSION" "patch")
                  
                  # Update package.json version
                  node -e "
                    const fs = require('fs');
                    const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                    pkg.version = '$NEW_VERSION';
                    fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
                  "
                  
                  CURRENT_VERSION=$NEW_VERSION
                  echo "ðŸ”„ Retrying publish with version $CURRENT_VERSION..."
                  
                  if npm publish --access public; then
                    echo "âœ… Successfully published $PACKAGE_NAME@$CURRENT_VERSION"
                    PUBLISHED_PACKAGES="$PUBLISHED_PACKAGES $PACKAGE_NAME@$CURRENT_VERSION"
                  else
                    echo "âŒ Failed to publish $PACKAGE_NAME@$CURRENT_VERSION after retry"
                    exit 1
                  fi
                else
                  echo "âŒ Unexpected publish error for $PACKAGE_NAME"
                  exit 1
                fi
              else
                echo "âŒ Unexpected publish error for $PACKAGE_NAME"
                exit 1
              fi
            fi
            
            cd - > /dev/null
          done

          echo "published=true" >> $GITHUB_OUTPUT
          echo "packages=$PUBLISHED_PACKAGES" >> $GITHUB_OUTPUT

      - name: Commit version updates
        if: steps.publish.outputs.published == 'true'
        run: |
          # Check if there are any uncommitted changes (version updates)
          if ! git diff --quiet; then
            echo "ðŸ“ Committing version updates..."
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git add .
            git commit -m "Update package versions after npm conflict resolution [skip ci]"
            git push
          else
            echo "âœ… No version updates to commit"
          fi

      - name: Create GitHub Release
        if: steps.publish.outputs.published == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');

            // Get latest tag
            let latestTag;
            try {
              latestTag = execSync('git describe --tags --abbrev=0', { encoding: 'utf8' }).trim();
            } catch (e) {
              latestTag = '';
            }

            // Generate changelog
            let changelog = '## Changes\n\n';
            if (latestTag) {
              try {
                const commits = execSync(`git log ${latestTag}..HEAD --oneline --no-merges`, { encoding: 'utf8' })
                  .trim()
                  .split('\n')
                  .filter(line => line.length > 0)
                  .map(line => `- ${line}`)
                  .join('\n');
                changelog += commits || 'No significant changes';
              } catch (e) {
                changelog += 'Unable to generate changelog';
              }
            } else {
              changelog += 'Initial release';
            }

            // Create release
            const tagName = `v${{ steps.version.outputs.version }}`;
            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: tagName,
              body: changelog + '\n\n**Published packages:**\n${{ steps.publish.outputs.packages }}',
              draft: false,
              prerelease: false
            });

  trigger-vercel-production:
    needs: [check-changes, publish-production]
    if: needs.publish-production.outputs.published == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Trigger Vercel Production Deployments
        id: deploy
        run: |
          # Parse project IDs from secrets
          PROJECT_IDS='${{ secrets.VERCEL_PROJECT_IDS }}'
          DEPLOYED_PROJECTS=""
          DEPLOYMENT_URLS=""

          echo "$PROJECT_IDS" | jq -r 'to_entries[] | "\(.key):\(.value)"' | while IFS=':' read -r PROJECT_NAME PROJECT_ID; do
            echo "ðŸš€ Deploying $PROJECT_NAME to production (ID: $PROJECT_ID)..."
            
            # Create production deployment using Vercel API with Git source for code changes
            RESPONSE=$(curl -s -X POST "https://api.vercel.com/v13/deployments" \
              -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "{
                \"name\": \"$PROJECT_NAME\",
                \"project\": \"$PROJECT_ID\",
                \"target\": \"production\",
                \"gitSource\": {
                  \"type\": \"github\",
                  \"ref\": \"feat/v3\",
                  \"sha\": \"${{ github.sha }}\",
                  \"repoId\": ${{ github.event.repository.id }}
                },
                \"meta\": {
                  \"githubCommitSha\": \"${{ github.sha }}\",
                  \"githubCommitAuthorName\": \"${{ github.actor }}\",
                  \"packageVersion\": \"${{ needs.publish-production.outputs.version }}\",
                  \"deploymentType\": \"production\",
                  \"triggeredBy\": \"github-actions\"
                }
              }")
            
            # Extract deployment URL and ID
            DEPLOYMENT_URL=$(echo "$RESPONSE" | jq -r '.url // empty')
            DEPLOYMENT_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
            ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message // empty')
            
            if [ -n "$DEPLOYMENT_URL" ] && [ -n "$DEPLOYMENT_ID" ]; then
              echo "âœ… Successfully triggered production deployment for $PROJECT_NAME"
              echo "ðŸ“ Production URL: https://$DEPLOYMENT_URL"
              DEPLOYED_PROJECTS="$DEPLOYED_PROJECTS $PROJECT_NAME"
              DEPLOYMENT_URLS="$DEPLOYMENT_URLS\\n- **$PROJECT_NAME**: https://$DEPLOYMENT_URL"
            else
              echo "âŒ Failed to deploy $PROJECT_NAME to production"
              if [ -n "$ERROR_MESSAGE" ]; then
                echo "Error: $ERROR_MESSAGE"
              fi
              echo "Response: $RESPONSE"
            fi
          done

          # Save results for GitHub release
          echo "deployed_projects=$DEPLOYED_PROJECTS" >> $GITHUB_OUTPUT
          echo -e "deployment_urls=$DEPLOYMENT_URLS" >> $GITHUB_OUTPUT

      - name: Update GitHub Release with Deployment Info
        if: steps.deploy.outputs.deployed_projects != ''
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentUrls = `${{ steps.deploy.outputs.deployment_urls }}`;
            const tagName = `v${{ needs.publish-production.outputs.version }}`;

            // Get the release
            let release;
            try {
              release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
            } catch (error) {
              console.log('Release not found, skipping deployment URL update');
              return;
            }

            // Update release body with deployment URLs
            const updatedBody = release.data.body + 
              '\n\n## ðŸš€ Deployment URLs\n' + 
              deploymentUrls;

            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.data.id,
              body: updatedBody
            });
